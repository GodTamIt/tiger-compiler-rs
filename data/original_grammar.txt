PROGRAM -> let DECLSEG in STMTS end
DECLSEG -> TYPEDECLS VARDECLS FUNCDECLS
TYPEDECLS -> EPSILON
TYPEDECLS -> TYPEDECL TYPEDECLS
TYPEDECL -> type id := TYPE ;
TYPE -> boolean
TYPE -> int
TYPE -> float
TYPE -> unit
TYPE -> id
TYPE -> array [ intlit ] of TYPE
VARDECLS -> EPSILON
VARDECLS -> VARDECL VARDECLS
VARDECL -> var IDS : TYPE OPTINIT ;
IDS -> id
IDS -> id , IDS
OPTINIT -> EPSILON
OPTINIT -> := CONST
FUNCDECLS -> EPSILON
FUNCDECLS -> FUNCDECL FUNCDECLS
FUNCDECL -> func id ( PARAMS ) : TYPE begin STMTS end ;
PARAMS -> EPSILON
PARAMS -> NEPARAMS
NEPARAMS -> PARAM
NEPARAMS -> PARAM , NEPARAMS
PARAM -> id : TYPE
STMTS -> FULLSTMT
STMTS -> FULLSTMT STMTS
FULLSTMT -> STMT ;
STMT -> LVALUE := EXPR
STMT -> if EXPR then STMTS endif
STMT -> if EXPR then STMTS else STMTS endif
STMT -> while EXPR do STMTS enddo
STMT -> for id := EXPR to EXPR do STMTS enddo
STMT -> break
STMT -> return EXPR
LVALUE -> id OPTOFFSET
OPTOFFSET -> EPSILON
OPTOFFSET -> [ EXPR ]
EXPRS -> EPSILON
EXPRS -> NEEXPRS
NEEXPRS -> EXPR
NEEXPRS -> EXPR , NEEXPRS
EXPR -> CLAUSE
EXPR -> EXPR | CLAUSE
CLAUSE -> PRED
CLAUSE -> CLAUSE & PRED
PRED -> AEXPR
PRED -> AEXPR CMP AEXPR
CMP -> =
CMP -> <>
CMP -> <=
CMP -> >=
CMP -> <
CMP -> >
AEXPR -> TERM
AEXPR -> AEXPR LINOP TERM
LINOP -> +
LINOP -> -
TERM -> FACTOR
TERM -> TERM NONLINOP FACTOR
NONLINOP -> *
NONLINOP -> /
FACTOR -> CONST
FACTOR -> id
FACTOR -> id [ EXPR ]
FACTOR -> id ( EXPRS )
FACTOR -> ( EXPR )
CONST -> true
CONST -> false
CONST -> _
CONST -> intlit
CONST -> floatlit