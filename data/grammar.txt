PROGRAM -> let DECLSEG in STMTS end
DECLSEG -> TYPEDECLS VARDECLS FUNCDECLS
TYPEDECLS -> EPSILON
TYPEDECLS -> TYPEDECL TYPEDECLS
TYPEDECL -> type id := TYPE ;
TYPE -> boolean
TYPE -> int
TYPE -> float
TYPE -> unit
TYPE -> id
TYPE -> array [ intlit ] of TYPE
VARDECLS -> EPSILON
VARDECLS -> VARDECL VARDECLS
VARDECL -> var IDS : TYPE OPTINIT ;
IDS -> id IDS'
IDS' -> EPSILON
IDS' -> , IDS
OPTINIT -> EPSILON
OPTINIT -> := CONST
FUNCDECLS -> EPSILON
FUNCDECLS -> FUNCDECL FUNCDECLS
FUNCDECL -> func id ( PARAMS ) : TYPE begin STMTS end ;
PARAMS -> EPSILON
PARAMS -> NEPARAMS
NEPARAMS -> PARAM NEPARAMS'
NEPARAMS' -> EPSILON
NEPARAMS' -> , NEPARAMS
PARAM -> id : TYPE
STMTS -> FULLSTMT STMTS'
STMTS' -> EPSILON
STMTS' -> STMTS
FULLSTMT -> STMT ;
STMT -> LVALUE := EXPR^
STMT -> if EXPR^ then STMTS STMT'
STMT -> while EXPR^ do STMTS enddo
STMT -> for id := EXPR^ to EXPR^ do STMTS enddo
STMT -> break
STMT -> return EXPR^
STMT' -> endif
STMT' -> else STMTS endif
LVALUE -> id OPTOFFSET
OPTOFFSET -> EPSILON
OPTOFFSET -> [ EXPR^ ]
EXPRS -> EPSILON
EXPRS -> NEEXPRS
NEEXPRS -> EXPR^ NEEXPRS'
NEEXPRS' -> EPSILON
NEEXPRS' -> , NEEXPRS
EXPR^ -> CLAUSE^ EXPR^'
EXPR^' -> EPSILON
EXPR^' -> | CLAUSE^ EXPR^'
CLAUSE^ -> PRED CLAUSE^'
CLAUSE^' -> EPSILON
CLAUSE^' -> & PRED CLAUSE^'
PRED -> AEXPR^ PRED'
PRED' -> EPSILON
PRED' -> CMP AEXPR^
CMP -> =
CMP -> <>
CMP -> <=
CMP -> >=
CMP -> <
CMP -> >
AEXPR^ -> TERM^ AEXPR^'
AEXPR^' -> EPSILON
AEXPR^' -> LINOP TERM^ AEXPR^'
LINOP -> +
LINOP -> -
TERM^ -> FACTOR TERM^'
TERM^' -> EPSILON
TERM^' -> NONLINOP FACTOR TERM^'
NONLINOP -> *
NONLINOP -> /
FACTOR -> CONST
FACTOR -> id FACTORID'
FACTOR -> ( EXPR^ )
FACTORID' -> EPSILON
FACTORID' -> [ EXPR^ ]
FACTORID' -> ( EXPRS )
CONST -> true
CONST -> false
CONST -> _
CONST -> intlit
CONST -> floatlit


==========
Removed left recursion from EXPR, TERM, AEXPR, and CLAUSE
Left factored IDS, NEPARAMS, STMT, NEEXPRS, PRED, and FACTOR
